<?xml version="1.0" encoding="utf-8"?>
<book xmlns="http://docbook.org/ns/docbook"
xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">

<title><trademark>InfiniSQL</trademark> Reference Manual</title>
<info><pubdate><?dbtimestamp format="Y-m-d H:M:S"?></pubdate>
<productname>InfiniSQL</productname><productnumber>0.1.1-alpha</productnumber></info>
<preface>
<title>Preface</title>
<para>
This is the reference manual for InfiniSQL. It describes configuration
settings and user capabilities such as SQL support, schema and user management,
and using the API for creating stored procedures.
It is based on the 0.1.1-alpha release, available on <link xl:href="http://github.com/infinisql/infinisql.git">GitHub</link>.
</para>
</preface>

<part>
<title><trademark>InfiniSQL</trademark> Configuration Reference Manual</title>
<partintro>
<para>
These entries describe all available configuration options for InfiniSQL as
well as the format of the config file.
</para>
</partintro>

<chapter>
<title>Configuration File Format and Parameters</title>
<refentry xml:id="configfile">
<refmeta>
  <refentrytitle>Configuration File</refentrytitle>
</refmeta>
<refnamediv>
  <refname>Configuration File</refname>
  <refpurpose>The structure and contents of the InfiniSQL configuration file.</refpurpose>
</refnamediv>
<refsect1>
  <title>Description of Configuration File</title>
<para>
InfiniSQL has only one configuration file, <filename>etc/infinisqlmgr.conf</filename>, and
it is read once upon startup. It is planned
in the near future to be a dynamically configurable system. But for the time being,
there is a single config file. It is read upon startup by
<command>infinisqlmgr/infinisqlmgr.py</command>, which uses Python's <link xl:href="http://docs.python.org/2/library/configparser.html">ConfigParser</link> module to process configuration
parameters. There is a sample configuration file shipped with the source called
<filename>etc/infinisqlmgr.conf-sample</filename>. This file contains all
necessary parameters to start up a single process InfiniSQL database.
  General configuration syntax, such as parameter assignments and commenting,
should be pretty self-explanatory. But they are explained in detail in the
ConfigParser documentation. All parameters are required. Some may have blank
values, but each parameter must be defined in the config file for InfiniSQL to
start correctly.
</para>
<para>
<bridgehead>
The following sections are defined in the config file:
</bridgehead>
</para>
<itemizedlist>
<listitem><para>[DEFAULT]</para>
<para>
This section contains parameters which pertain to other sections.
If a parameter does not appear explicitly in a particular section, but does appear
in [DEFAULT], then the parameter is still accessible from that section. This section
is described as part of Python's ConfigParser documentation.
</para></listitem>
<listitem><para>[global]</para>
<para>
  This section contains parameters which applies to all nodes within an InfiniSQL cluster.
</para>
</listitem>
<listitem><para>[node_[0-9]+]</para>
<para>
  Each <command>infinisqld</command> process within a cluster is defined within these
sections. InfiniSQL defines a node as a running <command>infinisqld</command> process--
any number of nodes may execute within a single host operating system instance. Likewise,
any number of hosts may have <command>infinisqld</command> node processes running upon
them.
Each node has a nodeid, which is defined by the numerals following the
underscore in the section definition. All nodes must have unique nodeid's, and they
should start with 1 and increase in single unit increments, such as [node_1], [node_2],
etc. Parameters which are unique to the node, such as <varname>member</varname>,
must be defined in the node's own section.
</para>
</listitem>
</itemizedlist>
<para>
  <bridgehead>Format Strings</bridgehead>
ConfigParser allows definition of format strings (which behave a lot like variables,
or symbol definitions). <filename>etc/infinisqlmgr.conf-sample</filename> includes
two such items, <varname>DEPLOYMENT_DIRECTORY</varname> and <varname>IPADDR</varname>.
<varname>DEPLOYMENT_DIRECTORY</varname> refers to the directory root into which
InfiniSQL has been installed. <varname>IPADDR</varname> refers to an IPV4 address.
These values are interpreted by ConfigParser, and not used by
<command>infinisqlmgr.py</command>. So you are free to use any format string
you want, if any, and to discard those used in the sample. The ConfigParser
documentation describes how format strings are interpolated.
</para>
</refsect1>
</refentry>

<refentry xml:id="username">
<refmeta>
  <refentrytitle>username</refentrytitle>
</refmeta>
<refnamediv>
  <refname>username</refname>
  <refpurpose>user as which <command>infinisqld</command> runs.</refpurpose>
</refnamediv>
<refsect1>
  <title>username</title>
<para>
This is the system userid as which <command>infinisqld</command> runs.
</para>
<example>
<title>username configuration</title>
  <para><varname>username</varname>: infinisql</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="sshkey">
<refmeta>
  <refentrytitle>sshkey</refentrytitle>
</refmeta>
<refnamediv>
  <refname>sshkey</refname>
  <refpurpose>ssh rsa (or dsa) key filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>sshkey</title>
<para>
This is the filename of the ssh private key used to log in to each host upon which
<command>infinisqld</command> node processes are to execute. This key should be
passphrase-less so that it does not require manual intervention after executing
<command>infinisqlmgr.py</command>. This key pair needs to be present in this
location only on the host from which <command>infinisqlmgr.py</command> is executed.
The public portion of the key needs to be in <filename>.ssh/authorized_keys</filename>
on each host running <command>infinisqld</command>.
</para>
<example>
<title>sshkey configuration</title>
  <para><varname>sshkey</varname>: /home/infinisql/.ssh/id_rsa</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ssh">
<refmeta>
  <refentrytitle>ssh</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ssh</refname>
  <refpurpose>ssh client filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>ssh</title>
<para>
This is the location of the ssh client on the system running <command>infinisqlmgr.py</command>.
Obviously, an <command>sshd</command> process needs to be running on each host.
</para>
<example>
<title>ssh configuration</title>
  <para><varname>ssh</varname>: /usr/bin/ssh</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="infinisql">
<refmeta>
  <refentrytitle>infinisqld</refentrytitle>
</refmeta>
<refnamediv>
  <refname>infinisqld</refname>
  <refpurpose>infinisqld filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>infinisqld</title>
<para>
This is the location of the <command>infinisqld</command> executable on the target host.
The InfiniSQL build process places <command>infinisqld</command> within the
<filename>sbin</filename> directory wherein InfiniSQL is installed.
</para>
<example>
<title>infinisqld configuration</title>
<para><varname>infinisqld</varname>: /home/infinisqld/infinisql_built/sbin/infinisqld</para>
</example>
<example>
<title>infinisqld configuration with format string interpolation</title>
  <para><varname>infinisqld</varname>: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="logfile">
<refmeta>
  <refentrytitle>logfile</refentrytitle>
</refmeta>
<refnamediv>
  <refname>logfile</refname>
  <refpurpose>infinisqld logfile.</refpurpose>
</refnamediv>
<refsect1>
  <title>logfile</title>
<para>
This is where error and information log messages are written by each infinisqld
process. Actually, there are three files. The two additional files are logfile with
extension .out and .err for stdout and stderr streams from the process, respectively.
Obviously, this is something which needs to be cleaned up as development progresses--but
this is how to find informational messages from running <command>infinisqld</command>
processes on each host. Multiple nodes running on a particular host should each have
a <varname>logfile</varname> entry defined to distinguish messages from each particular
process. The InfiniSQL build process creates a <filename>var</filename> directory upon
installation. This is intended to contain the <filename>logfile</filename>s, but
they can be written anywhere for which <varname>username</varname> has write permission.
</para>
<example>
<title>logfile configuration</title>
<para><varname>logfile</varname>: /home/infinisqld/infinisql_built/var/infinisqld.log</para>
</example>
<example>
<title>logfile configuration with format string interpolation</title>
  <para><varname>infinisqld</varname>: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld.log</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="globaladminpassword">
<refmeta>
  <refentrytitle>globaladminpassword</refentrytitle>
</refmeta>
<refnamediv>
  <refname>globaladminpassword</refname>
  <refpurpose>administrative password</refpurpose>
</refnamediv>
<refsect1>
  <title>globaladminpassword</title>
<para>
This is the password for the <varname>admin</varname> user in the
<varname>_global</varname> domain. This is the administrative user for the entire
cluster, and is the only user that exists after the cluster is started. Therefore,
all administrative activities are made possible through this user.
</para>
<example>
<title>globaladminpassword configuration</title>
  <para><varname>globaladminpassword</varname>: passw0rd</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="cfghostport">
<refmeta>
  <refentrytitle>cfghostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>cfghostport</refname>
  <refpurpose>IP:port to listen for configuration commands</refpurpose>
</refnamediv>
<refsect1>
  <title>cfghostport</title>
<para>
This is the IP:tcp port pair upon which <command>infinisqld</command> listens
for configuration commands coming from <command>infinisqlmgr.py</command>. The
IP portion must be numeric dotted-quad IPv4, or <varname>*</varname> (to listen
on all interfaces), and cannot be a host or other name. It must be reachable by
<command>infinisqlmgr.py</command>.
</para>
<example>
<title>cfghostport configuration</title>
  <para><varname>cfghostport</varname>: *:11520</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="cfgremotehostport">
<refmeta>
  <refentrytitle>cfgremotehostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>cfgremotehostport</refname>
  <refpurpose>destination IP:port for configuration commands</refpurpose>
</refnamediv>
<refsect1>
  <title>cfgremotehostport</title>
<para>
The is the IP:tcp port pair by which <command>infinisqlmgr.py</command> reaches
this <command>infinisqld</command> process to send it configuration commands.
It corresponds to the <varname>cfghost</varname> parameter. Having distinct
configuration parameters allows, for instance, clusters to be managed through
network address translation, but it does add a bit of configuration complexity.
Obviously, <command>infinisqlmgr.py</command> must be able to reach.
</para>
<example>
<title>cfgremotehostport configuration</title>
  <para><varname>cfgremotehostport</varname>: 10.101.2.1:11520</para>
</example>
<example>
<title>cfgremotehostport configuration with interpolation</title>
  <para><varname>cfgremotehostport</varname>: %(IPADDR)s:11520</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="mgmthost">
<refmeta>
  <refentrytitle>mgmthost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>mgmthost</refname>
  <refpurpose>hostname for <command>infinisqld</command> node</refpurpose>
</refnamediv>
<refsect1>
  <title>mgmthost</title>
<para>
The hostname passed to <command>ssh</command> to log into to launch
<command>infinisqld</command>. If this entry is blank, then
<command>infinisqlmgr.py</command> will launch <command>infinisql</command>
directly on the existing host.
</para>
<example>
<title>mgmthost configuration</title>
  <para><varname>mgmthost</varname>: node1.infinisql.org</para>
</example>
<example>
<title>mgmthost configuration with interpolation</title>
  <para><varname>mgmthost</varname>: %(IPADDR)s</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="listenhost">
<refmeta>
  <refentrytitle>listenhost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>listenhost</refname>
  <refpurpose>address to listen on for raw configuration</refpurpose>
</refnamediv>
<refsect1>
  <title>listenhost</title>
<para>
IPv4 address or hostname for <command>infinisqld</command> to service
configuration commands from clients.
This is used for user account and schema manipulation. This interface will
likely be deprecated in the near future. An '*' means to listen on all interfaces.
</para>
<example>
<title>listenhost configuration</title>
  <para><varname>listenhost</varname>: *</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="listenport">
<refmeta>
  <refentrytitle>listenport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>listenport</refname>
  <refpurpose>TCP port to listen on for raw configuration</refpurpose>
</refnamediv>
<refsect1>
  <title>listenport</title>
<para>
TCP port <command>infinisqld</command> to service
configuration commands from clients. Corresponds to <varname>listenhost</varname>.
</para>
<example>
<title>listenport configuration</title>
  <para><varname>listenport</varname>: 11521</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ibgatewayhostport">
<refmeta>
  <refentrytitle>ibgatewayhostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ibgatewayhostport</refname>
  <refpurpose>IP:port pair for inter-node cluster communication</refpurpose>
</refnamediv>
<refsect1>
  <title>ibgatewayhostport</title>
<para>
Other nodes in the cluster communicate to this <command>infinisqld</command> node
via this IP:port. If there are multiple
<varname>ibgateway</varname>s, then those after the first instance are assigned ports
in units ascending. So make sure that there are plenty of ports available to listen
upon directly above this value.
</para>
<example>
<title>ibgatewayhostport configuration</title>
  <para><varname>ibgatewayhostport</varname>: 10.10.10.5:11530</para>
</example>
<example>
<title>ibgatewayhostport configuration with interpolation</title>
  <para><varname>mgmthost</varname>: %(IPADDR)s:11530</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="pghost">
<refmeta>
  <refentrytitle>pghost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>pghost</refname>
  <refpurpose>host for SQL communication</refpurpose>
</refnamediv>
<refsect1>
  <title>pghost</title>
<para>
Clients connect to this hostname or address, or * for all interfaces on the host.
<command>infinisqld</command> uses the <link xl:href="http://www.postgresql.org/docs/devel/static/protocol.html">PostgreSQL Frontend/Backend Protocol</link> on this interface.
</para>
<example>
<title>pghost configuration</title>
  <para><varname>pghost</varname>: *</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="pgport">
<refmeta>
  <refentrytitle>pgport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>pgport</refname>
  <refpurpose>TCP port for SQL communication</refpurpose>
</refnamediv>
<refsect1>
  <title>pgport</title>
<para>
Clients connect to this TCP port, which corresponds to <varname>pghost</varname>.
</para>
<example>
<title>pgport configuration</title>
  <para><varname>pgport</varname>: 15432</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="transactionagents">
<refmeta>
  <refentrytitle>transactionagents</refentrytitle>
</refmeta>
<refnamediv>
  <refname>transactionagents</refname>
  <refpurpose>number of Transaction Agents</refpurpose>
</refnamediv>
<refsect1>
  <title>transactionagents</title>
<para>
The number of Transaction Agent actor threads to create for this node.
</para>
<example>
<title>transactionagents configuration</title>
  <para><varname>transactionagents</varname>: 8</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="engines">
<refmeta>
  <refentrytitle>engines</refentrytitle>
</refmeta>
<refnamediv>
  <refname>engines</refname>
  <refpurpose>number of Engines</refpurpose>
</refnamediv>
<refsect1>
  <title>engines</title>
<para>
The number of Engine actor threads to create for this node.
</para>
<example>
<title>engine configuration</title>
  <para><varname>engine</varname>: 4</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ibgateways">
<refmeta>
  <refentrytitle>ibgateways</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ibgateways</refname>
  <refpurpose>number of Inbound Gateways</refpurpose>
</refnamediv>
<refsect1>
  <title>ibgateways</title>
<para>
The number of Inbound Gateway actor threads to create for this node.
</para>
<example>
<title>ibgateway configuration</title>
  <para><varname>ibgateway</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="obgateways">
<refmeta>
  <refentrytitle>obgateways</refentrytitle>
</refmeta>
<refnamediv>
  <refname>obgateways</refname>
  <refpurpose>number of Outbound Gateways</refpurpose>
</refnamediv>
<refsect1>
  <title>obgateways</title>
<para>
The number of Outbound Gateway actor threads to create for this node.
</para>
<example>
<title>obgateway configuration</title>
  <para><varname>obgateway</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="anonymousping">
<refmeta>
  <refentrytitle>anonymousping</refentrytitle>
</refmeta>
<refnamediv>
  <refname>anonymousping</refname>
  <refpurpose>allow anonymous ping or not</refpurpose>
</refnamediv>
<refsect1>
  <title>anonymousping</title>
<para>
Whether to allow non logged-in users to send an InfiniSQL ping command through the
raw interface.
</para>
<example>
<title>anonymousping configuration</title>
  <para><varname>anonymousping</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="badloginmessages">
<refmeta>
  <refentrytitle>badloginmessages</refentrytitle>
</refmeta>
<refnamediv>
  <refname>badloginmessages</refname>
  <refpurpose>send bad login response messages or not</refpurpose>
</refnamediv>
<refsect1>
  <title>badloginmessages</title>
<para>
Whether to allow non logged-in users to send an InfiniSQL ping command through the
raw interface.
</para>
<example>
<title>badloginmessages configuration</title>
  <para><varname>badloginmessages</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="replica">
<refmeta>
  <refentrytitle>replica</refentrytitle>
</refmeta>
<refnamediv>
  <refname>replica</refname>
  <refpurpose>replica number of which this node is a member</refpurpose>
</refnamediv>
<refsect1>
  <title>replica</title>
<para>
The replica number, starting with 0, to which the node belongs. Currently, only
replica 0 is available. This parameter must be set to 0.
</para>
<example>
<title>replica configuration</title>
  <para><varname>replica</varname>: 0</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="member">
<refmeta>
  <refentrytitle>member</refentrytitle>
</refmeta>
<refnamediv>
  <refname>member</refname>
  <refpurpose>index in replica to which this node belongs</refpurpose>
</refnamediv>
<refsect1>
  <title>member</title>
<para>
Each replica has one or more member nodes. This parameter defines the member number
for the particular node, starting at member 0. All member numbers must be
contiguous whole numbers in a replica. Each node must have a unique member number.
</para>
<example>
<title>member configuration</title>
  <para><varname>member</varname>: 7</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="userschemamgrnode">
<refmeta>
  <refentrytitle>userschemamgrnode</refentrytitle>
</refmeta>
<refnamediv>
  <refname>userschemamgrnode</refname>
  <refpurpose>node on which the User Schema Manager actor thread runs</refpurpose>
</refnamediv>
<refsect1>
  <title>userschemamgrnode</title>
<para>
This parameter must be only in the [global] section. It defines the node upon
which the User Schema Manager actor runs. There can only be one User Schema Manager
per replica.
</para>
<example>
<title>userschemamgrnode</title>
  <para><varname>userschemamgrnode</varname>: 2</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="deadlockmgrnode">
<refmeta>
  <refentrytitle>deadlockmgrnode</refentrytitle>
</refmeta>
<refnamediv>
  <refname>deadlockmgrnode</refname>
  <refpurpose>node on which the Deadlock Manager actor thread runs</refpurpose>
</refnamediv>
<refsect1>
  <title>deadlockmgrnode</title>
<para>
This parameter must be only in the [global] section. It defines the node upon
which the Deadlock Manager actor runs. There can only be one User Schema Manager
per replica.
</para>
<example>
<title>deadlockmgrnode</title>
  <para><varname>deadlockmgrnode</varname>: 2</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="activereplica">
<refmeta>
  <refentrytitle>activereplica</refentrytitle>
</refmeta>
<refnamediv>
  <refname>activereplica</refname>
  <refpurpose>the replica that supports client interaction</refpurpose>
</refnamediv>
<refsect1>
  <title>activereplica</title>
<para>
This parameter must be only in the [global] section. It defines the replica
which is the master for all data, to which other replicas are replicated. Currently,
only a single replica is functional, defined as replica 0. This value must be 0.
</para>
<example>
<title>activereplica</title>
  <para><varname>activereplica</varname>: 0</para>
</example>
</refsect1>
</refentry>

</chapter>

<article>
  <title>infinisqlmgr.conf Examples</title>
<section><title>infinisqlmgr.conf Examples</title>

<example>
  <title>Single Node, infinisqlmgr.py on same host as <command>infinisqld</command> node</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost:
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=127.0.0.1
replica: 0
member: 0
</programlisting>
</example>

<example>
  <title>Single Node, infinisqlmgr.py on separate host from <command>infinisqld</command> node</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost: %(IPADDR)s
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=10.102.2.1
replica: 0
member: 0
</programlisting>
</example>

<example>
<title>Eight Nodes, infinisqlmgr.py on separate host from <command>infinisqld</command></title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost: %(IPADDR)s
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=10.102.2.1
replica: 0
member: 0

[node_2]
IPADDR=10.102.2.2
replica: 0
member: 1

[node_3]
IPADDR=10.102.2.3
replica: 0
member: 2

[node_4]
IPADDR=10.102.2.4
replica: 0
member: 3

[node_5]
IPADDR=10.102.2.5
replica: 0
member: 4

[node_6]
IPADDR=10.102.2.6
replica: 0
member: 5

[node_7]
IPADDR=10.102.2.7
replica: 0
member: 6

[node_8]
IPADDR=10.102.2.8
replica: 0
member: 70
</programlisting>
</example>

<example>
<title>Two Nodes, each running on same host with infinisqlmgr.py</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost:
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

IPADDR=127.0.0.1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
replica: 0
member: 0

[node_2]
replica: 0
member: 1
cfghostport: *:21520
cfgremotehostport: %(IPADDR)s:21520
listenport: 21521
ibgatewayhostport: *:21530
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld2.log
pgport: 15433
</programlisting>
</example>

</section>
</article>

</part>

<!-- follows is good yo -->
<part>
  <title><trademark>InfiniSQL</trademark> User Reference Manual</title>  
<partintro>
<para>
This is the reference manual for using InfiniSQL. It includes descriptions
of SQL capabilities, schema management, user management, and the stored
procedure API. There's also an overview of how they tie together.
</para>
</partintro>

<chapter>
<title>Using InfiniSQL</title>
<para>
Users can interact with a running InfiniSQL cluster over TCP on each node in
the <varname>activereplica</varname>. For the time being, that needs to be
configured as 0. From a user's standpoint, there is no difference between
any of the nodes in a replica other than TCP/IP connection settings. All
users, schemata, and data are accessible from each node in the cluster.
</para>
<para>
The workflow for using InfiniSQL, once up and running, is as follows:
<orderedlist>
  <listitem>
    <para>
      Login as administrative user and create a domain and a user
associated with the new domain.
    </para>
  </listitem>
<listitem>
  <para>
    Login as newly-created user. Create schema and tables and indices.
  </para>
</listitem>
<listitem>
  <para>
Optionally create stored procedures and load them.
  </para>
</listitem>
<listitem>
  <para>
    Login as newly-created user. Manipulate data via SQL.
  </para>
</listitem>
</orderedlist>
User and Schema Management is accomplished via a distinct TCP/IP port and
wire protocol from those used for SQL. This is because the means to
manipulate users and schema objects was implemented in InfiniSQL before the
SQL capabilities were added. It is planned to deprecate the original, raw
interface, in favor of the SQL interface, but for the time, this raw
interface is the only way to accomplish user and schema administration tasks.
</para>
</chapter>

<chapter>
<title>User and Schema Management</title>
<para>
Each schema and user is associated with one and only one particular domain.
There is a special domain called <quote><varname>_global</varname></quote>
from which all other domains and users are created. This is the only domain
contained in an InfiniSQL cluster when it is started. Tied to the
<varname>global</varname> domain is the username <varname>admin</varname>.
This user's password is set in the configuration parameter
<varname>globaladminpassword</varname>. The TCP/IP connection settings for
this interface are described in the configuration parameters
<varname>listenhost</varname> and <varname>listenport</varname>.
</para>
<para>
All user and schema management capabilities are available through
<command>perl</command> subroutines contained in 
<filename>scripts/infinisql.plib</filename> in the source tree. The specific
wire protocol format is expressed in this file, as well as in
<filename>infinisqld/TransactionAgent.cc</filename>. But using the
<command>perl</command> subroutines is definitely the fastest way to get up
and running. Simply put a line that says <quote><code>require 'infinisql.plib';</code></quote>
early in a perl script, and use the routines with the appropriate commands.
</para>

<section>
<title>
  Perl API for User and Schema Management
</title>
<para>
  Examples for use of these functions abound in the <filename>scripts/</filename> and <filename>scripts/benchmark/</filename> directories.
</para>

  <refentry xml:id="connect">
    <refmeta>
        <refentrytitle>connect</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>connect</refname>
        <refpurpose>open TCP connection to InfiniSQL node</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;connect(host, port);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>send</secondary></indexterm>
            <indexterm><primary>connect function</primary></indexterm>
    
        <function>connect</function> to InfiniSQL node on
<varname>host:port</varname>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="send">
    <refmeta>
        <refentrytitle>send</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>send</refname>
        <refpurpose>send a command</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;send(command, args...);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>send</secondary></indexterm>
            <indexterm><primary>send command function</primary></indexterm>
    
        <function>send</function> <varname>command</varname> with list
of arguments. Command and all arguments must be string-type. Either enclosed in single or double-quotes, or SCALAR variables whose values were assigned in quotes. So, sending the argument 4 must be done as <quote>4</quote>, for instance.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="describeresponse">
    <refmeta>
        <refentrytitle>describeresponse</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>describeresponse</refname>
        <refpurpose>show response of sent command</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;describeresponse(&amp;send(host, port));
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>describeresponse command</secondary></indexterm>
            <indexterm><primary>describeresponse function</primary></indexterm>
    
Describes response from a command submitted via <function>send</function>
function. There are at least 2 lines of output. The first line has 3 integer values separated by tabs. The first 2 values are the length of the response
string from the server. The 3rd value is the response code. 0 means
successful command completion, non-zero is otherwise. The response codes are defined in <filename>infinisqld/infinisql_defs.h</filename>.
Subsequent lines of output are results of the command, if any. If the command
returns no data, then a 0 is present on the second line of output.
      </para>
      </refsect1>
 </refentry>



  <refentry xml:id="disconnect">
    <refmeta>
        <refentrytitle>disconnect</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>disconnect</refname>
        <refpurpose>close TCP connection to InfiniSQL node</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;disconnect;
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>disconnect</secondary></indexterm>
            <indexterm><primary>disconnect function</primary></indexterm>
    
        <function>disconnect</function> the socket
created by a previous call to <function>connect</function>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="fireforget">
    <refmeta>
        <refentrytitle>fireforget</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>fireforget</refname>
        <refpurpose>send command without collecting response</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;fireforget(command, args...);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>fireforget</secondary></indexterm>
            <indexterm><primary>send command function with no wait for response</primary></indexterm>
    
Like the <function>&amp;send</function> subroutine, but don't wait for response
from server. This cannot be used in conjunction with <function>&amp;describeresponse</function>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="getcommand">
    <refmeta>
        <refentrytitle>getcommand</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>getcommand</refname>
        <refpurpose>read commands from standard input</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>&amp;describeresponse(&amp;send(&amp;getcommand));</code>
</para>
    </refsynopsisdiv>
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>getcommand</secondary></indexterm>
            <indexterm><primary>getcommand function</primary></indexterm>
    
Reads commands from standard input. The first line is the command itself.
Subsequent commands are arguments. EOF (CTRL-d) on an empty line submits the
command and arguments. Output of <function>&amp;getcommand</function> should be
fed to <function>&amp;send</function>.
      </para>
      </refsect1>
 </refentry>

</section>

<section>
<title>User and Schema Commands</title>
<para>
These commands are used to login via the raw TCP interface and then to
administer user and schema objects. The InfiniSQL perl subroutine
<function>&amp;send</function> can be used to submit these commands. Each
command and
argument should be sent as a quoted string, including numeric values. This
interface will be deprecated in the near future, but is currently the only
way to do necessary activities, such as creating users, tables, and so on.
The basic steps necessary to prepare for SQL data manipulation are as follows:

<orderedlist>
  <listitem>
    <para>
      <function>&amp;connect(...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("login", &lt;admin credentials&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createdomain", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createuser", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("logout")</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;connect(...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("login", &lt;credentials created above&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createschema")</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createtable", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;1st column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;2nd column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;nth column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("compile", &lt;UPDATE accounttable SET balance += 1000000 where username='mtravis'&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("loadprocedure", &lt;GimmeMoney.so&gt;)</function>
    </para>
  </listitem>

</orderedlist>

<note><para>
The previous commands are not necessarily syntactically correct, but are
displayed for illustration of the workflow. Refer to the specific reference
entries for each command for correct usage.</para></note>

From here, it's possible to log in and manipulate data in the created tables
either with ad hoc SQL commands and with any stored procedures that have
been loaded.

</para>

<refentry xml:id="login">
<refmeta>
  <refentrytitle>login</refentrytitle>
</refmeta>
<refnamediv>
  <refname>login</refname>
  <refpurpose>login to an InfiniSQL node via the raw interface</refpurpose>
</refnamediv>
<refsect1>
  <title>login</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
  <listitem>
    <para>
      username
    </para>
  </listitem>
  <listitem>
    <para>
      password
    </para>
  </listitem>
</itemizedlist>
Login to InfiniSQL. For a newly-started cluster, the only domain is "_global"
and its only user is "admin". The password is set in the config parameter
<varname>globaladminpassword</varname>.
</para>
<example>
<title>login example</title>
  <para>&amp;send("login", "_global", "admin", "passw0rd");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="logout">
<refmeta>
  <refentrytitle>logout</refentrytitle>
</refmeta>
<refnamediv>
  <refname>logout</refname>
  <refpurpose>logout from an InfiniSQL node via the raw interface</refpurpose>
</refnamediv>
<refsect1>
  <title>logout</title>
<para>
No parameters.
</para>
<para>
Logout of InfiniSQL. The TCP/IP connection is also severed, so
<function>&amp;connect</function> needs to be submitted before
<function>login</function> to login again.

</para>
<example>
<title>logout example</title>
  <para>&amp;send("logout");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createdomain">
<refmeta>
  <refentrytitle>createdomain</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createdomain</refname>
  <refpurpose>create domain</refpurpose>
</refnamediv>
<refsect1>
  <title>createdomain</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
</itemizedlist>
Create a domain called <varname>domainname</varname>. This command can
only be executed by the <varname>admin</varname> user of the
<varname>_global</varname> domain.
</para>
<example>
<title>createdomain example</title>
  <para>&amp;send("createdomain", "texas");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createuser">
<refmeta>
  <refentrytitle>createuser</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createuser</refname>
  <refpurpose>create a user</refpurpose>
</refnamediv>
<refsect1>
  <title>createuser</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
  <listitem>
    <para>
      username
    </para>
  </listitem>
  <listitem>
    <para>
      password
    </para>
  </listitem>
</itemizedlist>
Creates user <varname>username</varname> associated with domain
<varname>domainname</varname> with password <varname>password</varname>.
This command can
only be executed by the <varname>admin</varname> user of the
<varname>_global</varname> domain.
</para>
<example>
<title>createuser example</title>
  <para>Create user <varname>mayor</varname> in domain
<varname>texas</varname> with password <varname>austin</varname>:
  </para>
<para>
&amp;send("createuser", "texas", "mayor", "austin");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createschema">
<refmeta>
  <refentrytitle>createschema</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createschema</refname>
  <refpurpose>create schema</refpurpose>
</refnamediv>
<refsect1>
  <title>schema</title>
<para>
No Parameters.
</para>
<para>
Create a schema associated with the logged in domain. Only one schema
can exist per domain, and a schema must be present for tables and indices
to be created.
</para>
<example>
<title>createschema example</title>
  <para>&amp;send("createschema");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createtable">
<refmeta>
  <refentrytitle>createtable</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createtable</refname>
  <refpurpose>create a table</refpurpose>
</refnamediv>
<refsect1>
  <title>createtable</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      tablename
    </para>
  </listitem>
</itemizedlist>
Returns numeric tableid.
</para>
<para>
Create a table within schema of logged-in domain. Unlike SQL's <code>CREATE TABLE</code>, this only creates a bare table with no columns or indices.
</para>
<example>
<title>createtable example</title>
  <para>&amp;send("createtable", "mastertable");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="addcolumn">
<refmeta>
  <refentrytitle>addcolumn</refentrytitle>
</refmeta>
<refnamediv>
  <refname>addcolumn</refname>
  <refpurpose>adds a column and optional index to a table</refpurpose>
</refnamediv>
<refsect1>
  <title>addcolumn</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      tableid
    </para>
  </listitem>
  <listitem>
    <para>
      type
    </para>
  </listitem>
  <listitem>
    <para>
      length (0 for all <varname>type</varname>s other than <varname>charx</varname>
    </para>
  </listitem>
  <listitem>
    <para>
      columnname
    </para>
  </listitem>
  <listitem>
    <para>
      indextype
    </para>
  </listitem>
</itemizedlist>
Returns numeric columnid of newly created column.
</para>
<para>
Create a new column with optional index. At least one column per table
must have an index, or else <code>SELECT</code> will not be able to retrieve
data. <varname>tableid</varname> is the return value from the 
<function>createtable</function> call on the associated table.
</para>

<para>
The possible data types are as follows, with their descriptions.
<itemizedlist>
  <listitem>
    <para>
      <varname>int</varname>: 64bit signed integer
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>bool</varname>: 0 or 1
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>float</varname>: 128bit floating point
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>char</varname>: single 8-byte character
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>charx</varname>: <varname>length</varname> 8-byte characters
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>varchar</varname>: characters of arbitrary length
    </para>
  </listitem>
</itemizedlist>

Indextypes are:
<itemizedlist>
  <listitem>
    <para>
      <varname>none</varname>: no index type
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>unique</varname>: all values must be unique (while allowing multiple nulls)
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>nonunique</varname>: values need not be unique
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>uniquenotnull</varname>: values unique, with no nulls. Equivalent to SQL <code>PRIMARY KEY</code>
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>nonuniquenotnull</varname>: values need not be unique, and no nulls allowed
    </para>
  </listitem>
</itemizedlist>

</para>
<example>
<title>addcolumn example</title>
  <para>Create integer column <varname>accountid</varname> on tableid 1
with unique and not null constraints:
  </para>
<para>&amp;send("addcolumn", "1", "int", "0", "accountid", "uniquenotnull");</para>
<para>
  Other examples abound under the <filename>scripts/</filename> directory.
</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="compile">
<refmeta>
  <refentrytitle>compile</refentrytitle>
</refmeta>
<refnamediv>
  <refname>compile</refname>
  <refpurpose>compile a SQL statement</refpurpose>
</refnamediv>
<refsect1>
  <title>compile</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      statementname
    </para>
  </listitem>
  <listitem>
    <para>
      statement
    </para>
  </listitem>
</itemizedlist>
Returns <varname>statementname</varname>.
</para>
<para>
Compile a SQL statement for use in stored procedures. Parameters for the
statement are within the statement, and are of the form <code>:[0-9]+</code>.
Parameters must start at 0, and increment in single units. Allowed parameters
are for column values to insert, update, or in search expressions. Table and
column names cannot be stored procedure parameters.
</para>
<example>
<title>compile example</title>
  <para>&amp;send("compile", "creditseller", "UPDATE accountstable SET balance = balance + :0 where accountid = :1");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="loadprocedure">
<refmeta>
  <refentrytitle>loadprocedure</refentrytitle>
</refmeta>
<refnamediv>
  <refname>loadprocedure</refname>
  <refpurpose>load a stored procedure</refpurpose>
</refnamediv>
<refsect1>
  <title>loadprocedure</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      pathname
    </para>
  </listitem>
  <listitem>
    <para>
      procedurename
    </para>
  </listitem>
</itemizedlist>
Returns <varname>statementname</varname>.
</para>
<para>
Load a previously-compiled stored procedure into each running
<command>infinisqld</command> instance in the cluster. This stored
procedure is a C++ module which gets dynamically loaded. It must be
present as <filename>pathname</filename> on every host which runs
1 or more <command>infinisqld</command> nodes. Stored procedures must
be loaded after SQL statements which they contain are
<command>compile</command>d. The <varname>procedurename</varname> must
correspond to the procedure name within the stored procedure source, explained
more fully in a separate part of this documentation.
</para>
<example>
<title>loadprocedure example</title>
  <para>&amp;send("loadprocedure", "/home/infinisql/infinisql_built/procs/PgbenchNoinsertProc.so", "PgbenchNoInsert");</para>
</example>
</refsect1>
</refentry>

</section>

</chapter>

<chapter>
<title>SQL Reference</title>
<para>
InfiniSQL uses the <link xl:href="http://www.postgresql.org/docs/9.2/static/protocol.html">PostgreSQL Frontend/Backend Protocol, Version 3</link>. This
means that any PostgreSQL client version 7.4 or later, regardless of platform
or language, should be able to connect to InfiniSQL. InfiniSQL does not
support PostgreSQL compiled statements, which are frequently implemented
by default on client side libraries, such as for <command>perl</command>.
InfiniSQL has been tested using the <command>psql</command> command-line
tool as well as the <function>DBD::Pg</function> <command>perl</command>
library. For <command>perl</command>, the <varname>pg_server_prepare</varname> parameter to connect
via <function>DBD::Pg</function> must be set to 0. Similar configuration
for other languages may need to be performed in order for those libraries to
work with InfiniSQL.
<note><para>No code from PostgreSQL, except for macro definitions
(in <filename>infinisqld/pgoids.h</filename>)
necessary to implement the Frontend/Backend Protocol, is included in
InfiniSQL.</para></note>

InfiniSQL does not support SSL (yet), so connections are unencrypted. Also,
InfiniSQL only listens on TCP/IP ports, and not UNIX domain sockets. The
TCP/IP host and port for each node are configured by the <varname>pghost</varname> and <varname>pgport</varname> parameters in <filename>etc/infinisqlmgr.conf</filename>. Clients can connect to any running node. All database contents
are available identically from all nodes. InfiniSQL only supports
clear text passwords currently--clients normally negotiate this properly,
but if you try to force InfiniSQL to use some other method, such as MD5
hashing, then authentication will fail. The InfiniSQL notion of domain
is equivalent to PostgreSQL's database. So, connecting to a database via
PostgreSQL client maps to the domain created previously.

<example>
  <title>
    Connecting via <command>psql</command>.
  </title>
<programlisting>
psql -h 127.0.0.1 -p 15432 -d texas -U mayor
</programlisting>
<para>
  Connects to <command>infinisqld</command> node on localhost port 15432.
Domain name is "texas" and userid "mayor". A password prompt appears next.
If no dbname is sent, then the server will attempt to authenticate the 
username with the same domainname, just like a PostgreSQL server
</para>
</example>

<note>
  <para>
    Not all capabilities available through commands in the <command>psql</command> client are functional when connected to an InfiniSQL database. If they send
a command to the server which is currently unsupported, such as <command>\d</command>, then an error message will be returned. Those commands which do not
communicate with the backend work properly.
  </para>
</note>

If a query does not succeed, then an error response is generated. Only
a handful of error types and messages are currently emitted.
<note>
  <para>
    One error type returned is 55P03 <quote>lock not available</quote>. This
happens when a transaction attemps to lock a record which is
already locked. A workaround is to retry the transaction until
the message goes away. If the record never unlocks, it's because some
other transaction has never released it. Deadlock managment is currently
not implemented. These limitations will be corrected in a release very
soon.
  </para>
</note>


</para>

<refentry xml:id="insert">
<refmeta>
  <refentrytitle>INSERT</refentrytitle>
</refmeta>
<refnamediv>
  <refname>insert</refname>
  <refpurpose>Inserts records into a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>insert</title>
<para>
INSERT INTO &lt;tablename&gt; VALUES (&lt;value list&gt;);
</para>
<note>
  <para>
    All column values for a record must be listed, comma-separated,
 in column order. InfiniSQL does not yet support default column values.
  </para>
</note>
<example>
<title>INSERT example</title>
  <para>INSERT INTO mastertable VALUES (5, false, 88);</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="select">
<refmeta>
  <refentrytitle>SELECT</refentrytitle>
</refmeta>
<refnamediv>
  <refname>select</refname>
  <refpurpose>Retrieves records from a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>select</title>
<para>
SELECT &lt;* | column list&gt; FROM &lt;tablename&gt; [WHERE &lt;search expression&gt;];
</para>
<para>
Only a single table can be included--InfiniSQL currently does not support
joins. The search expression supports the following SQL-92 predicates:
COMPARISON (=, &lt;&gt;, &lt;, &gt;, &lt;=, and &gt;=), BETWEEN, NULL, IN, LIKE, NOT BETWEEN,
NOT NULL, NOT IN, and NOT LIKE.
</para>
<para>
These are the most common search expression predicates in use.  These
predicates can be combined with AND, and OR, such as: <quote><code>WHERE cola=7 AND colc BETWEEN 7 AND 43</code></quote>. NOT is only supported where listed above. <quote><code>NOT (WHERE cola=7 OR colc BETWEEN 7 AND 43)</code></quote>, for example, is not supported by InfiniSQL. Other predicates,
such as EXISTS and UNIQUE, will be implemented in an upcoming release.
The fields in the search expression must have some index type assigned when
created by <command>addcolumn</command>.
The script
<command>scripts/regression.pl</command> attempts to test all of the
supported predicate types and combinations.

</para>
<example>
<title>SELECT example</title>
  <para>SELECT * FROM mastertable WHERE accountid >= 25;</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="update">
<refmeta>
  <refentrytitle>UPDATE</refentrytitle>
</refmeta>
<refnamediv>
  <refname>update</refname>
  <refpurpose>Modifies records in a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>update</title>
<para>
UPDATE &lt;tablename&gt; SET &lt;list of fieldname [=, +=, -=, *=, /=] [-+]value, ...&gt; [WHERE &lt;search expression&gt;];
</para>
<para>
The search expression capabilities are the same as for SELECT.
</para>
<example>
<title>UPDATE example</title>
  <para>UPDATE intuniquetable set intunique2=60 WHERE intunique2=50;</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="delete">
<refmeta>
  <refentrytitle>DELETE</refentrytitle>
</refmeta>
<refnamediv>
  <refname>delete</refname>
  <refpurpose>Deletes records in a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>update</title>
<para>
DELETE FROM &lt;tablename&gt; [WHERE &lt;search expression&gt;];
</para>
<para>
The search expression capabilities are the same as for SELECT.
</para>
<example>
<title>DELETE example</title>
  <para>DELETE FROM liketable WHERE charxcol LIKE 'abcdefghijklmnopqrstuvwxyz';</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="selectstoredproc">
<refmeta>
  <refentrytitle>SELECTSTOREDPROC</refentrytitle>
</refmeta>
<refnamediv>
  <refname>selectstoredproc</refname>
  <refpurpose>Execute stored procedure.</refpurpose>
</refnamediv>
<refsect1>
  <title>selectstoredproc</title>
<para>
SELECT &lt;procname&gt; (&lt;parameterlist&gt;);
</para>
<para>
The results of this query are formatted like those from a SELECT query.
</para>
<example>
<title>SELECTSTOREDPROC example</title>
<para>
  SELECT SqlProc (20, 90, 35);
</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="transactions">
<refmeta>
  <refentrytitle>TRANSACTIONS</refentrytitle>
</refmeta>
<refnamediv>
  <refname>transactions</refname>
  <refpurpose>Perform transactions.</refpurpose>
</refnamediv>
<refsect1>
  <title></title>
<para>
<quote>BEGIN [WORK];</quote> to start transactions. <quote>ROLLBACK [WORK]</quote> to roll back. <quote>COMMIT [WORK]</quote> to commit. <quote>END</quote> is
a synonym for <quote>CONNECT</quote>.
</para>
<para>
InfiniSQL behaves with auto-commit based on the variable
<varname>session_isautocommit</varname> in the Pg class 
(<filename>infinisqld/Pg.cc &amp; infinisqld_Pg.h</filename>). It is currently
set to <command>true</command> in the source. Auto-commit is where the
server puts each individual statement into a transaction and executes it
if there is no active transaction when the statement was typed. If a 
transaction is manually started with <command>BEGIN</command>, then
auto-commit does not apply. If a statement causes an error while in a
transaction, then no further statements will be executed until <command>ROLLBACK</command> is received.
</para>
</refsect1>
</refentry>

</chapter>

<article>
  <title>
    Future SQL Capabilities
  </title>
<section>
  <title>Future SQL Capabilities</title>
<para>
Put simply, if the SQL capabilities are not described above, then they
likely aren't available in InfiniSQL as of release 0.1.1-alpha. Places
to look in the code mainly include <filename>infinisqld/lexer.ll, parser.yy,
Asts.cc, infinisql_Asts.cc, Larxer.cc, infinisql_Larxer.cc, Transaction.cc,
 infinisql_Transaction.h, Pg.cc, and infinisql_Pg.h</filename>.
Missing
standard features are planned for future releases. Some are more simple
to implement than others. The InfiniSQL code base is able to support
all standard SQL features while still maintaining its uniquely scalable
transaction processing capabilities. Much of the code for these
features has already been written, but not yet completed.
It's just a matter of development
effort to bring these capabilities to life.

These include, but aren't limited to:

<itemizedlist>
  <listitem>
    <para>
      Lock &amp; deadlock management
    </para>
  </listitem>
  <listitem>
    <para>
Joins
    </para>
  </listitem>
  <listitem>
    <para>
Subqueries
    </para>
  </listitem>
  <listitem>
    <para>
ORDER BY, GROUP BY (aggregate), HAVING clauses
    </para>
  </listitem>
  <listitem>
    <para>
CREATE TABLE, CREATE COLUMN, etc.: all data definition, to deprecate
the commands in the raw interface, such as <command>createtable</command>,
<command>addcolumn</command>, and the like.
    </para>
  </listitem>
</itemizedlist>
</para>
</section>
</article>

<chapter>
<title>Stored Procedure API</title>
<para>
  This here is about whatsy-hoo.
</para>
<refentry xml:id="storedproc">
<refmeta>
  <refentrytitle>storedproc</refentrytitle>
</refmeta>
<refnamediv>
  <refname>storedproc</refname>
  <refpurpose>Stored Procedure Programming</refpurpose>
</refnamediv>
<refsect1>
  <title>storedproc</title>
<para>
Working examples of InfiniSQL stored procedures and how they are built
are located in the <filename>procs/</filename> directory of the source
distribution. The <command>makem.sh</command> script builds them and
deploys to the <filename>procs/</filename> directory in the installation
directory corresponding to the <code>--prefix</code> option to
<command>./configure</command>. This installation directory must be passed as
an argument to <command>makem.sh</command>.
</para>
<para>
  Stored procedures are dynamically-loaded custom C++ classes. The structure and
contents of the source files are driven in part by requirements for
dynamically loaded C++ classes and functions. This <link xl:href="http://www.isotton.com/devel/docs/C++-dlopen-mini-HOWTO/C++-dlopen-mini-HOWTO.html">HOWTO</link> is a good basis for understanding how dynamic C++ modules are implemented.
Stored procedures link against a single library, <filename>&lt;installationdir&gt;/lib/libinfinisql.so</filename>. They must include multiple headers, however,
from <filename>&lt;installationdir&gt;/include/</filename>. Ideally, the
header requirements would be simplified from refactoring the API code, but
for the time being, multiple headers are necessary. Class factory function
prototypes to instantiate and delete stored procedure objects are as follows:

<funcsynopsis>
  <funcprototype>
    <funcdef>extern "C" ApiInterface* <function>InfiniSQL_&lt;domainname&gt;_&lt;procedurename&gt;_create</function></funcdef>
<paramdef>
  TransactionAgent *<parameter>taPtr</parameter>
</paramdef>
<paramdef>
  ApiInterface *<parameter>pgPtr</parameter>
</paramdef>
<paramdef>
  void <parameter>destructorPtr</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

<funcsynopsis>
  <funcprototype>
    <funcdef>extern "C" ApiInterface* <function>InfiniSQL_&lt;domainname&gt;_&lt;procedurename&gt;_destroy</function></funcdef>
<paramdef>
  ApiInterface *<parameter>p</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

<varname>domainname</varname> is that submitted by <command>createdomain</command> and <varname>procedurename</varname> is from <command>loadprocedure</command>, and invoked through SQL with <quote><code>SELECT &lt;procname&gt; (&lt;parameterlist&gt;)</code></quote>. Since the class
factories are global functions, this ensures that no name space conflict
occurs between domains. 
<note>
  <para>
    Since stored procedures are dynamically loaded C++ programs, there is
no way for <command>infinisqld</command> to protect from fatal errors
caused by custom stored procedure code.
  </para>
</note>

</para>
<para>
To avoid name conflicts, the custom class <emphasis>should</emphasis>
follow a similar naming convention as that of the factory functions--but
the author has set a bad example in the shipped procedures themselves.
The class must inherit from <classname>class ApiInterface</classname>.
</para>
<para>
  Beyond syntactic requirements--which should be inferable quite easily
from the source code anyway--a very important characteristic of stored
procedure programming is that of continuations. <command>infinisqld</command>
makes heavy use of asynchronous event processing to allow a relatively
small number of threads to handle massive concurrent workloads. Most
transaction operations, such as performing SQL queries, involve message
passing between multiple threads. No threads block waiting for replies.
Instead, they store the state of the transaction and proceed to work
on other activities as events occur. When an appropriate response message
is received, the transaction picks up where it left off. InfiniSQL
implements continuations by storing the return function and
its intended parameter values to be called later. This is home-brew
continuations. Better solutions likely exist, such as <function>setjmp/longjmp</function>, but that can be solved in the future through refactoring. The
return function for stored procedures must have the following
definition:

<funcsynopsis>
  <funcprototype>
    <funcdef>void <function>&lt;funcname&gt;_&lt;</function></funcdef>
<paramdef>
  int64_t<parameter>entrypoint</parameter>
</paramdef>
<paramdef>
  void *<parameter>statePtr</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

Allowable function names are from the <classname>class ApiInterface</classname>, and are
<function>continueFunc1</function> and
<function>continueFunc2</function>.
Other continuation functions which must be defined in each stored procedure,
but which also <emphasis>must not</emphasis> be used, are
<function>continuePgFunc</function>,
<function>continuePgCommitimplicit</function>,
<function>continuePgCommitexplicit</function>,
<function>continuePgRollbackimplicit</function>, and
<function>continuePgRollbackexplicit</function>. These functions are used
by <classname>class Pg</classname>, which also inherits from
<classname>class ApiInterface</classname>. All custom logic for the
stored procedure must occur either in the constructor function,
<function>continueFunc1</function> or <function>continueFunc2</function>.
<varname>entrypont</varname> can be used to keep track of state, such as through
a <function>switch</function> statement within <function>contnueFunc1</function>
or <function>continueFunc2</function>. Alternately, state can be maintained
in class member variables.
</para>

<refsect2>
  <title>
    Sending Results and Exiting
  </title>
<para>
  Stored procedure results are sent as rows and columns from a <command>SELECT</command> query. For InfiniSQL, this means populating the following:
<itemizedlist>
  <listitem>
    <para>pgPtr->results.selectFields</para>
  </listitem>
  <listitem>
    <para>pgPtr->results.selectResults, and</para>
  </listitem>
  <listitem>
    <para>pgPtr->results.statementStatus</para>
  </listitem>
</itemizedlist>

Those objects are described in <filename>infinisqld/infinisql_Pg.h</filename>.
</para>
<para>
  Exiting means deleting the <classname>Statement</classname> object associated with the client's stored procedure invocation "<code>SELECT Proc (...)</code>, deleting the
current object and then executing the
function to continue the Pg object which called the stored procedure. An
example is in <filename>procs/PgbenchNoinsertProc.cc</filename>
<function>exitProc</function>.
</para>
</refsect2>

<refsect2>
<title>Relevant ApiInterface Member Variables</title>
<para>
  <itemizedlist>
    <listitem>
      <para>
	<varname>ApiInterface *pgPtr</varname>: Pg
object which called stored procedure. Also the object to which control will
return when procedure exits.
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>TransactionAgent *taPtr</varname>: TransactionAgent
actor thread object associated with <varname>pgPtr</varname>
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>int64_t domainid</varname>: numeric indentifier for 
associated <varname>domainname</varname>
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>Transaction *transactionPtr</varname>: associated Transaction object 
(or NULL if no open transaction)
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>vector&lt;std::string&gt; pgPtr->statementPtr->queries[0].storedProcedureArgs</varname>: Arguments passed to stored procedure as formatted strings
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>struct results_s results</varname>: results from transaction
function calls
      </para>
    </listitem>
  </itemizedlist>
</para>
</refsect2>

</refsect1>


</refentry>
</chapter>

</part>

</book>
